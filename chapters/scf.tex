\chapter{R Package singleCellFeatures}
\label{ch:singlecellfeatures}

The format in which CellProfiler feature data is stored is only of limited suitability for exploratory data analysis. CellProfiler was originally implemented in the proprietary MATLAB language but has recently been ported to Python as version 2.x, in order to move away from the drawbacks of relying on a closed-source, commercial interpreter. Unfortunately, InfectX workflows are all based on CellProfiler 1.x and there are no current plans for updating to version 2.x. Consequently, all available single cell feature data is stored as MATLAB (Level 5) MAT-files.

The way in which storage is organized, while apt for working with a limited number of features corresponding to an entire plate, is unfitting if a large number of features belonging only to a subset of cells (e.g. all cells in a specific well) are of interest. Features are saved plate-wise in individual, gzip-compressed files, typically 1--\SI{3}{\mega\byte} in size and making the data contained in several hundred (depending on pathogen and generation the analysis pipeline, 500--700 features exist) such files available to an R session\footnote{Using R version 3.2.0 \citep{RCoreTeam2015}, installed as precompiled binaries running under Mac OS 10.10.5 on a \SI{3.4}{\giga\hertz} Intel Core i7-2600 platform (iMac12,2) with \SI{32}{\giga\byte} RAM. Whenever computational timing information is given and nothing else is specified, this is the reference system used to obtain the measurements.}, using R.matlab version 3.2.0, \cite{Bengtsson2015}, takes on the order of \SI{30}{\minute}.

As MATLAB does not constitute a tool that is particularly popular in the field of statistics and does not provide many of the convenience functions, available to R, that are much appreciated in exploratory data analysis, it was decided to convert single cell feature data as generated by CellProfiler 1.x into a format natively accessible by an R environment. Due to the amount of time involved, this cannot be performed as a first step of every analysis and owing to the amount of storage necessary, it makes little sense to be carried out beforehand for all plates. Therefore, a system is needed, capable of fetching data that is not available locally, preprocessing it for direct access by R and storing the results for future use.

Furthermore, data-structures were developed, representing the hierarchy of single cell \gls{hts} data and capable of accommodating some associated metadata. Methods for operations that are frequently performed on such data are implemented in order to simplify many analysis tasks. With growing complexity of the code-base, it was decided to create an R-package that bundles the described capabilities.

Two similar projects, cellHTS2 \citep{Boutros2006} and RNAither \citep{Rieber2009}, both hosted on Bioconductor \citep{Huber2015}, were looked at but none of them fulfilled the requirements imposed by the InfectX datasets. While cellHTS2 is designed for microarray data or \gls{sirna} data obtained by a plate reader (yielding a scalar value per well), RNAither can handle data at the single cell level. It is, however, geared towards running analysis on a single feature, obtained on a single imaging channel and cannot accommodate the heterogeneity of data available from the InfectX image analysis pipeline. In addition, RNAither is neither optimized for the large amount of data associated with several hundred features, nor does it provide the sought after tools for handling such a dataset, rather than implementing a fixed analysis procedure that can be readily applied to a single intensity feature. The newly developed singleCellFeatures therefore constitutes a further step in the evolution of R packages for \gls{sirna} data analysis, starting with cellHTS2 which is generalized in a vertical fashion by RNAither with the increase in resolution from wells to cells, which in turn is extended horizontally by singleCellFeatures to include many different features.

Much effort during development of singleCellFeatures was spent for ensuring the necessary flexibility to accommodate any possible kind of feature and for implementing some crucial sections in a way that is efficient enough for interactive usage. The former task is achieved by allowing features to consist of a single value per well, a single value per cell or a vector of values per cell and only minimally relying feature naming conventions, while the latter issue is best illustrated by the following introductory example.

\input{R/scf-intro/getData}
\input{R/scf-intro/plot}

\label{ex:efficiency}
As proposed by \cite{Knapp2011} and \cite{Snijder2012}, the population context of each cell may significantly influence some morphological properties, confound phenotypic information that is measured during feature extraction and therefore has to be accounted for. They propose several features that may act as proxies to characterize aspects of population context, one of which is whether a cell is located towards the border of a colony or is surrounded by cells in all directions. In order to approximate this information from location data, an image is divided into 2-dimensional bins or facets and the number of cells per bin is counted. Cells that are located adjacent to one or more bins that are empty are considered edge cells and cells surrounded by non-empty bins are center cells. Figure \ref{fig:scf-intro_plot} visualizes the concept by color-coding facets according to the number of non-empty neighbors.

\begin{rlisting}{Calculation of population context features as implemented by \citeauthor{Knapp2011}.}{In order to detect whether a cell is located towards the border of a colony or is surrounded by neighboring cells, each well is divided into 2-dimensional bins and the number of cells per bin is counted. As implemented by \citeauthor{Knapp2011}, all bins are iterated, each of the 8 possible directions is checked for an empty neighbor and the corresponding binary value is saved to the current group of cells.}{edgepos}{p}
\input{R/scf-intro/edgepos}
\end{rlisting}

Code listing \ref{lst:edgepos} is taken from the implementation developed by \citeauthor{Knapp2011}, which was kindly supplied as supplement to their publication. While iterating over all facets, only exploiting vectorization within facets and heavily relying on if-else logic, might be a feasible approach, using datasets of the size the authors provide as exemplary material combined with permanently storing the results, such an approach is impractical with datasets as produced by InfectX. Still, the authors warn that:

\begin{quote}
These [population context feature] computations require considerable amounts of memory, and will take some time. This must be done for each of the input files, and will produce an output file containing the input data plus computed population features.
\end{quote}

\begin{rlisting}{A more efficient implementation of calculating population context features, developed for singleCellFeatures.}{Due to the larger number of cells per well and the increase in image resolution as compared to data used in \cite{Knapp2011}, calculation of border/center population context features have to be carried out in a more efficient manner, which can be accomplished by fully vectorizing the problem.}{facetBorder}{p}
\input{R/scf-intro/facetBorder}
\end{rlisting}

\input{R/scf-intro/rnaicell}
An execution of the code, using the supplied exemplary dataset (number of cells per well: $\mu=\knitrScfRnaicellCellnoMean$, $\sigma=\knitrScfRnaicellCellnoSd$; 15 bins in x-direction and 15 bins in y-direction) reveals that of the \knitrScfRnaicellTotal\ spent on calculating population context features, \knitrScfRnaicellEdgepos\ (\knitrScfRnaicellPercentage\ of the total time) is spent on determining positions within colonies. This performance can be expected to deteriorate significantly, using InfectX data, due to a ten-fold increase in cell counts and more importantly a 3-fold rise in resolution in both x- and y direction. The surge in dataset size entails an increase in number of bins needed, to obtain sensible results (the example in figure \ref{fig:scf-intro_plot} is divided into 36 bins per dimension) and runtime scales as $\mathcal{O}(n^2)$ in number of bins per dimension.

Neither the high computational cost, and consequently not even storing the results, however are necessities, as demonstrated by a slightly optimized implementation (see listing \ref{lst:facetBorder}). Fully vectorizing the problem no longer requires the extensive use of if-else logic and due to R being an interpreted language, built for operating on vectors, such an approach can be expected to bring about compelling speed improvements. Vectorization is achieved by calculating the indices of the 8 neighboring bins for each facet and applying this stencil to the 2-dimensional matrix containing binary empty/non-empty information per bin. This efficiently yields the number of empty neighbors for each facet which then can be mapped to cells by their column-major grid indices. An additional advantage of the presented implementation is that the number of empty neighbors is obtained for free whereas the code proposed by \citeauthor{Knapp2011} would perform even worse if modified to produce this supplementary information, as the full set of if-statements has to be run to the end for each facet.

\input{R/scf-intro/benchmark}
Benchmarking the two implementations reveals that a \knitrScfBenchmarkSpeedup -fold speedup is easily achievable only by completely vectorizing the problem. While the original code takes \knitrScfBenchmarkEdgeTotal\ per plate (384 iterations of the same well; $\mu=\knitrScfBenchmarkEdgeMean$, $\sigma=\knitrScfBenchmarkEdgeSd$; well H6 of plate J107-2C), total runtime is reduced to \knitrScfBenchmarkFacetTotal\ ($\mu=\knitrScfBenchmarkFacetMean$, $\sigma=\knitrScfBenchmarkFacetSd$, per well).

Such time-savings might not look that significant at first sight. But within the context of the available data, consequences of critical optimizations are of great value. First of all, interactive data analysis is sensitive to waiting times that exceed a few minutes and due to there not only being a single location feature to be analyzed, but rather 5--10, several minutes per feature are impractical. Moreover, if run-times can be sufficiently reduced, this makes it possible to run calculations on the fly instead of constantly saving results. Apart from the obvious downsides arising from storage overhead, management of result caches leads to practical issues whenever the workflow is under development and thus subject to constant change. Caches have to be invalidated and recomputed and the system overseeing these processes has to be made aware of changes, as well as understand where they apply. Furthermore, updating batches of data at once incurs substantial cost which might even be expended in vain if not all data is used before the next update triggers recomputation. Just in time generation of derived features is preferable over ahead of time calculation and the benefits justify optimization efforts.

\input{R/scf-intro/fullPlate}
When looking at runtimes of the original implementation obtained for benchmarking (\knitrScfBenchmarkEdgeTotal) and for a single execution on the supplied exemplary dataset (\knitrScfRnaicellEdgepos) side by side, a large discrepancy stands out. The two values are not directly comparable, as they are created with individual binning and differently sized datasets. But instead of explaining the divergence, these factors separate the two values even further, as the benchmarked time was obtained using a dataset roughly ten times larger and 6-fold more bins (225 versus 1296). Running the code of \citeauthor{Knapp2011} with InfectX data, as to be expected, takes significantly longer and determining cell position within colony for a single location feature over an entire plate is estimated to run for \knitrScfFullPlateRnaicellTime.\footnote{Due to the long running time, not all wells are processed, but \knitrScfFullPlateNSamp\ wells are randomly sampled and the mean per well is extrapolated to the full plate. The wells are \knitrScfFullPlateSampWell\ of plate J107-2C.} The exact same results can be computed within \knitrScfFullPlateMyTime\ by the code integrated in singleCellFeatures through vectorization as discussed previously and by splitting the data into wells.

Listing \ref{lst:edgepos} does not entirely reproduce the code of \citeauthor{Knapp2011}, but constitutes a simplified version intended for highlighting the importance of vectorization and adapted for comparison with the optimized variant. Originally, the nested for-loops iterating the bins (lines 6--12 and 14--37), are enclosed by an additional for-loop, iterating the wells. Data is stored as a large dataframe and all operations are performed on full-length vectors. The enormous number of comparisons resulting from this setup leads to serious performance issues, which are amplified when increasing the number of cells from $\sim 180000$ to $\sim 10^6$ per plate. Such observations, along with other considerations lead to development of a more sophisticated data structure for storing single cell feature data (see section \ref{sec:s3-objects}), which splits the data into smaller units and consequently eliminates constant comparisons against well indices for per-well operations.

The following sections discuss some design aspects and implementation issues of singleCellFeatures, beginning with data structures developed for representing single cell feature data, continuing with how data is acquired and locally cached, management of metadata and concluding with some tools for manipulating datasets and providing the data to third-party tools. This architectural overview is complemented by a more practical section in appendix \ref{ch:scf-manual}. For all coding, the style guide outlined in \cite{Wickham2014} was followed and \cite{Wickham2015} served as an invaluable reference, along with the extensive documentation supplied by \cite{RCoreTeam2015}. Package documentation is in-source with \mintinline{text}{.Rd} files generated by roxygen2 \citep{Wickham2015a}.

\section{S3 Classes}
\label{sec:s3-objects}
\Gls{oop} in R can be achieved by any one of the three distinct object systems S3, S4 and \glspl{rc}. While the RC system resembles the \gls{oop} style most people coming from languages such as Java or C++ are familiar with, by implementing message-passing, features such as mutability (in-place modification of objects) and pass-by-reference semantics violate common expectations of R users. S3 and S4 objects are built on the concept of generic function \gls{oop}, which does not associate methods with classes, but employs a special type of function, called a generic function, that is responsible for method dispatch. Of the two, S3 classes are more loosely organized, lacking the formal definitions of the S4 system which can describe both representation and (multiple) inheritance. Furthermore, S4 objects are capable of multiple dispatch and all code used for creating and manipulating S4 objects is not part of base R but supplied by the methods package, which introduces a new operator, $@$, for accessing object slots.

Much base functionality in R is implemented using S3 classes, including lm and glm objects, the support for which has been available to R from its very beginning. The methods package for S4 objects is attached by default since version 1.7.0, but fewer packages make use of the newer syntax, examples include the base package stats4 and CRAN packages Matrix and lme4. Bioconductor packages on the other hand are frequently designed on top of S4 classes. \Gls{rc} was only introduced with R 2.12 as part of the methods package and therefore currently does not enjoy widespread adoption. The limitations of S3 were found to be unproblematic for the planned feature set of singleCellFeatures and due to the attractive simplicity of this scheme, several objects are implemented as S3 classes.

\subsection{Metadata Objects}
\input{R/metadataAnalysis}
\label{sec:metadata-objects}
Metadata is extracted from aggregate files (see section \ref{sec:aggregate-files}) and used to generate both plate-level and well-level metadata objects. These consist of key-value pairs stored as lists and accompany all plate-level and well-level data objects generated by singleCellFeatures. The R class attribute names are \mintinline{text}{PlateMeta data} or \mintinline{text}{WellMetadata} and both are associated with a superordinate object name \mintinline{text}{Metadata} in order to simplify method dispatch in cases where a function is able to operate on both object types. Table \ref{tab:plate-metadata} shows the 12 slots along with short descriptions that constitute a \mintinline{text}{PlateMetadata} object, while table \ref{tab:well-metadata} does the same for an object of type \mintinline{text}{WellMetadata} (20 key-value pairs in total). Several slots, namely \mintinline{text}{plate.barcode}, \mintinline{text}{plate.quality}, \mintinline{text}{experiment.name}, \mintinline{text}{experiment.pathogen}, \mintinline{text}{experiment.geneset} and \mintinline{text}{experiment.library}, are redundant and therefore only listed in table \ref{tab:plate-metadata}.

\renewcommand{\arraystretch}{1.5}
\setlength{\tabcolsep}{0.2em}
\begin{table}
  \centering
  \caption[Key-value pairs constituting the \mintinline{text}{PlateMetadata} structure.]{\mintinline{text}{PlateMetadata} structures consist of 12 key-value pairs intended to capture all relevant plate-wide metadata.}
  \label{tab:plate-metadata}
  \footnotesize
  \begin{tabular}{L{0.25\linewidth}L{0.7\linewidth}}
    Key name &
      Description \\
    \hline 
    \mintinline{text}{plate.barcode} &
      The unique identifier assigned to every plate, for example \mintinline{text}{KB02-1L}. \\
    \mintinline{text}{plate.quality} &
      Plate quality descriptors are \knitrScfMetadatPlateQualityStat, but currently most (\knitrScfMetadatPlateQualityFrac) are assigned the label \mintinline{text}{UNKNOWN}. \\
    \mintinline{text}{plate.type} &
      Possible values for plate type are \knitrScfMetadatPlateTypes\ and different types are characterized by their control layout. \\
    \mintinline{text}{experiment.space} &
      The first hierarchy level of data organization in openBIS. Current spaces are \knitrScfMetadatSpaces \\
    \mintinline{text}{experiment.group} &
      The group level is used to sort data according to pathogen (e.g. \mintinline{text}{ADENO_TEAM}). \\
    \mintinline{text}{experiment.name} &
      At the experiment level, data is grouped into screens. An example value is \mintinline{text}{ADENO-DP-K1}. \\
    \mintinline{text}{experiment.pathogen} &
      While the pathogen is already encoded in the openBIS hierarchy of InfectX, this is not necessarily so. In case of a different setup, the treatment applied to the screen can be saved separately. \\
    \mintinline{text}{experiment.geneset} &
      Different sets of genes are investigated throughout all screens and possible values are \knitrScfMetadatGeneset. \\
    \mintinline{text}{experiment.replicate} &
      Designates the replicate number of the current plate (see table \ref{tab:infectx-replicates}). \\
    \mintinline{text}{experiment.library} &
      Manufacturers that provided \gls{sirna} reagents to infectX are \knitrScfMetadatLibrary. \\
    \mintinline{text}{experiment.batch} &
      Alphanumeric identifier for the batch in which the current plate was put through the wet-lab procedure. \\
    \mintinline{text}{counts.quantiles} &
      The lower and upper 5\% quantiles for cell counts over all 3456 images of the plate, determined in order to detect bad wells. \\
    \hline 
  \end{tabular}
\end{table}

\begin{table}
  \centering
  \caption[Metadata key-value pairs that make up \mintinline{text}{WellMetadata} objects.]{Analogously to \mintinline{text}{PlateMetadata} objects, \mintinline{text}{WellMetadata} classes consist of several key-value pairs. All slots that appear in both \mintinline{text}{Metadata} definitions (\mintinline{text}{plate.barcode}, \mintinline{text}{plate.quality}, \mintinline{text}{experiment.name}, \mintinline{text}{experiment.pathogen}, \mintinline{text}{experiment.geneset} and \mintinline{text}{experiment.library}) are excluded from this overview. Please refer to table \ref{tab:plate-metadata} for more information.}
  \label{tab:well-metadata}
  \footnotesize
  \begin{tabular}{L{0.25\linewidth}L{0.7\linewidth}}
    Key name &
      Description \\
    \hline 
    \mintinline{text}{well.row} &
      Alphabetic index of the current well row (possible values are A through P). \\
    \mintinline{text}{well.col} &
      Integer-valued column index of the current well (possible values are 1--24). \\
    \mintinline{text}{well.index} &
      Well indices are calculated from row and column location and represent linearized, row-major well positions within plates. \\
    \mintinline{text}{well.type} &
      Descriptor for the type of well, the most important of which include \mintinline{text}{SIRNA}, \mintinline{text}{POOLED_SIRNA} and \mintinline{text}{CONTROL}. \\
    \mintinline{text}{well.quality} &
     Possible values for this field are \knitrScfMetadatWellQualityStat, while most wells currently are set to \mintinline{text}{UNKNOWN} (\knitrScfMetadatWellQualityFrac). \\
    \mintinline{text}{gene.name} &
      Gene symbol corresponding to the targeted gene \citep{Gray2013}. \\
    \mintinline{text}{gene.id} &
      Entrez Gene ID of the targeted gene \citep{Maglott2011}. \\
    \mintinline{text}{sirna.name} &
      The \gls{sirna} catalog ID as specified by the manufacturer. \\
    \mintinline{text}{sirna.sequence} &
      Full sequence of the 5'-3' \gls{sirna} antisense (guide) strand added to the current well. \\
    \mintinline{text}{sirna.seed} &
      The seed sequence (nucleotides 2--9 from the 5' end) of the 5'-3' \gls{sirna} guide strand. \\
    \mintinline{text}{sirna.target} &
      Sense sequence of the \gls{sirna} target. \\
    \mintinline{text}{counts.cells} &
      The cell count of the current well. \\
    \mintinline{text}{counts.pathogen} &
      Count of recognized pathogen objects (in \textit{Bartonella} screens, the number of invasomes). \\
    \mintinline{text}{counts.infection} &
      Number of infected cells according to \gls{dtis}. \\
    \hline 
  \end{tabular}
\end{table}

Having metadata structures available alongside the objects holding single cell features facilitates manipulation of the data as all relevant information is bundled and does not have to be managed separately by the user. Furthermore, information stored in \mintinline{text}{well.type} can be used for normalization (sometimes it is desirable to only normalize non-control wells) and fields like \mintinline{text}{gene.name}, \mintinline{text}{gene.id} or \mintinline{text}{sirna.name} are used often for selecting the desired subset of data. The two slots \mintinline{text}{plate.quality} and especially \mintinline{text}{well.quality} hold promise for automatically discarding bad data, but current annotation levels leave much to be desired (\knitrScfMetadatPlateQualityFrac\ and \knitrScfMetadatWellQualityFrac, respectively, are labeled as \mintinline{text}{UNKNOWN}) due to the large amount of manual labor that is involved. Perhaps, if some form of automatic quality assessment is developed or if the results from focus detection are utilized to enhance data quality comments, these fields could be put to use.

Originally, inspired by the cellHTS2 package, it was planned to use public databases for collecting further metadata, such as gene ontology, chromosomal location, gene function summaries and homology. The bioconductor package biomaRt \citep{Durinck2005,Durinck2009} can be used to query several web services, including Ensembl, Uniprot and Reactome with gene IDs \citep{Maglott2011} and retrieve gene annotations. Furthermore, \gls{sirna} sequences could be used for investigating \glspl{ote} and developing methods in order to correct for such effects. Unfortunately, time constrains so far have prevented such ideas from being explored further.

\subsection{Data Objects}
Central to the presented R package are data structures that hold single cell feature data. Instead of just storing all data as a large \mintinline{text}{data.frame} as in RNAither, a more complex scheme was developed that represents the physical hierarchy of \gls{hts} datasets. This has both the advantage of presenting an intuitive structure of the data that can easily be navigated and efficiency benefits, as selecting cells from a well does not involve $10^6$ comparisons, but finding a slot in a list structure of length 384 (for consequences of the former approach, see the introductory example staring on page \pageref{ex:efficiency}).

Three types S3 objects represent the levels, data can be sorted by: 6 or 9 \mintinline{text}{ImageData} classes are assembled into a \mintinline{text}{WellData} object (which is additionally associated with a \mintinline{text}{WellMetadata} object) and 384 \mintinline{text}{WellData} structures, together with a \mintinline{text}{PlateMetadata} instance, compose a \mintinline{text}{PlateData} object. The respective collections of child objects are gathered in list structures named \mintinline{text}{data} (please refer to figure \ref{fig:scf-platedata} for a visualization of this hierarchy). Name attribute are organized similarly as for metadata objects, with a superordinate tag \mintinline{text}{Data} assigned in addition to the individual descriptors, in order to be able to define functions that can be applied to all data objects in the same way.

The next logical level is the screen (\gls{sirna} library), but clustering several \mintinline{text}{PlateData} objects is infeasible with current hardware. As R keeps all loaded objects in memory and a plate consisting of \tilde 600 features on \tilde$10^6$ cells requires \tilde \SI{8}{\giga\byte}, only large memory systems could handle such data structures.

\begin{figure}
  \centering
  \begin{tikzpicture}[%
    leaf/.style={grow=down,xshift=1em,anchor=west, edge from parent path={%
      (\tikzparentnode.south) |- (\tikzchildnode.west)}
    },
    level 1/.style={sibling distance=18em},
    level 2/.style={sibling distance=4em},
    level 3/.style={sibling distance=14em},
    level 4/.style={sibling distance=4em},
    vertex style/.style={
      draw=#1,
      thick,
      fill=#1!70,
      text=white,
      minimum width=1cm,
      minimum height=0.5cm,
      font=\footnotesize
    }
  ]
    \node[vertex style=Turquoise]{PlateData}
    [edge from parent fork down]
    child{node[vertex style=SeaGreen] {PlateMetadata}
      child[leaf,level distance=6ex] {%
        node[vertex style=BurntOrange]{plate.barcode}}
      child[leaf,level distance=12ex] {%
        node[vertex style=BurntOrange]{plate.quality}}
      child[leaf,level distance=18ex] {%
        node[vertex style=BurntOrange] {plate.type}}
      child[leaf,level distance=24ex] {%
        node[vertex style=BurntOrange] {\ldots}}
      child[leaf,level distance=30ex] {%
        node[vertex style=BurntOrange] {experiment.library}}
    }
    child {node[vertex style=MidnightBlue] {data}
      child {node[vertex style=Turquoise] {A1}}
      child {node[vertex style=Turquoise] {A2}
        child {node[vertex style=SeaGreen] {WellMetadata}
          child[leaf,level distance=6ex] {%
            node[vertex style=BurntOrange]{well.index}}
          child[leaf,level distance=12ex] {%
            node[vertex style=BurntOrange]{well.type}}
          child[leaf,level distance=18ex] {%
            node[vertex style=BurntOrange] {gene.name}}
          child[leaf,level distance=24ex] {%
            node[vertex style=BurntOrange] {\ldots}}
          child[leaf,level distance=30ex] {%
            node[vertex style=BurntOrange] {sirna.sequence}}
        }
        child {node[vertex style=MidnightBlue] {data}
          child {node[vertex style=Turquoise] {img\_11}
            child[leaf,level distance=6ex] {%
              node[vertex style=BurntOrange]{image.index}}
            child[leaf,level distance=12ex] {%
              node[vertex style=BurntOrange]{\ldots}}
            child[leaf,level distance=18ex] {%
              node[vertex style=MidnightBlue]{data.vec}}
            child[leaf,level distance=24ex] {%
              node[vertex style=MidnightBlue]{data.mat}}
            child[leaf,level distance=30ex] {%
              node[vertex style=MidnightBlue] {data.lst}}
          }
          child {node[vertex style=Turquoise] {img\_12}}
          child {node[vertex style=Turquoise] {\ldots}}
          child {node[vertex style=Turquoise] {img\_33}}
        }
      }
      child {node[vertex style=Turquoise] {\ldots}}
      child {node[vertex style=Turquoise] {P24}}
    };
  \end{tikzpicture}
  \caption[Data structure used for representing a complete plate of single cell data.]{Single cell data is organized according to the hierarchy imposed by \gls{hts} experiment design. Plates are divided into wells which are subdivided into images and Metadata objects (green) are attached at each level. Data objects provided by singleCellFeatures are in light blue and contain lists of subordinate objects (dark blue), while Metadata objects consist of key-value pairs (orange).}
  \label{fig:scf-platedata}
\end{figure}

The slots of \mintinline{text}{ImageData} objects are \mintinline{text}{plate} (barcode), \mintinline{text}{well.index} (linear, row-major, $\in \{ 1, 2, \dotsc, 384 \}$), \mintinline{text}{well.row} ($\in \{ A, B, \dotsc, P \}$), \mintinline{text}{well.col} ($\in \{ 1, 2, \dotsc, 24 \}$), \mintinline{text}{image.index} (linear, row-major, $\in \{ 1, 2, \dotsc, 6 \} \lor \{ 1, 2, \dotsc, 9 \}$, depending on number of imaging sites), \mintinline{text}{image.row} ($\in \{ 1, 2 \} \lor \{ 1, 2, 3 \}$, for 6 and 9 image wells, respectively), \mintinline{text}{image.col} ($\in \{ 1, 2, 3 \}$, independent on total number of images), \mintinline{text}{image.total} ($\in \{ 6, 9 \}$), \mintinline{text}{counts.quantiles}, \mintinline{text}{counts.cells}, \mintinline{text}{data.vec}, \mintinline{text}{data.mat} and \mintinline{text}{data.lst}. All but the last three are key-value pairs and most are self explanatory or have been described in section \ref{sec:metadata-objects} on metadata objects.

Actual feature data is split according to dimensionality with respect to images. Scalar-valued entities (such as object counts, minima, maxima, etc.) are saved into \mintinline{text}{data.vec} which is represented as a vector-valued \mintinline{text}{data.frame} (in order to accommodate both numerical and character data). Vector-valued features (the bulk of single cell data) are assembled into matrices, dependent on object counts, which are added to \mintinline{text}{data.mat}. While there are typically as many nuclei as cells, those features can be merged into the same matrix, but pathogen objects require their own data structure, as pathogen counts are different from cell counts. Furthermore, it may happen that cell features come in different lengths due to segmentation errors. A final group of features is vector-valued per cell (matrix-valued per image) and is saved to the \mintinline{text}{data.lst} node. Currently, neighbor features are detected and converted to sparse adjacency matrices, using the Matrix package \citep{Bates2015}, while others, such as parent\slash child features, are represented by nested list structures.

One obvious advantage of the proposed data representation is storage efficiency for values that apply to groups of cells, such as plate and well-level metadata or all features of the \mintinline{text}{data.vec} group. When using a large matrix for all data, this information has to be duplicated \tilde 400 times at image level, \tilde 3500 times at well level and \tilde $10^6$ times at plate level, incurring significant storage overhead. This can be mitigated somewhat by using factors and the resulting structures can still be handled well by current hardware, but nonetheless, parsimony is desirable. For these reasons, metadata objects at image level were not developed, as they unnecessarily inflate object size, despite this breaking recursive symmetry. Instead, only the minimally necessary information for identifying the data source is attached at this level.

In retrospect, it is debatable whether spiting data into images is sensible or creates unnecessary computational overhead in traversing nested lists. At the time of original implementation it was unclear if all images could be treated equally and having this level of granularity available seemed important. With access to some practical experience in working with such structures, this feature may not be worth the complexity it entails. Splitting the data at well level, however has proven to be worthwhile.

\subsection{Auxiliary Objects}
Several additional S3 objects are implemented in an auxiliary capacity. Both \mintinline{text}{PlateLocation} and \mintinline{text}{WellLocation} classes serve to communicate the identity and location of datasets, while \mintinline{text}{PlateAggregate} and \mintinline{text}{MatData} objects are used for caching purposes.

Objects representing data locations are simple key-value lists that are instantiated with a barcode in case of \mintinline{text}{PlateLocation} or a barcode and a row\slash column specification for \mintinline{text}{WellLocation} objects. Subsequent population of slots \mintinline{text}{space}, \mintinline{text}{group} and \mintinline{text}{experiment} is performed by lookup of the information in the \mintinline{text}{plate.database} table (see section \ref{sec:plate-database}), which is an optimization measure necessary to speed up creation times severely hampered by retrieving the values from large aggregate files. The information contained in \mintinline{text}{DataLocation} (the class attribute to specify any of the two location types) objects uniquely specifies where the described dataset is located on openBIS and in local file-system cache and they are mainly used for unifying package-internal communication.

\begin{rlisting}{Exemplary application of \mintinline{text}{DataLocation} objects.}{Mostly used for internal communication of dataset identity and location both within openBIS and the local file system, \mintinline{text}{DataLocation} objects simplify certain tasks such as lookup of cache files.}{getCacheFilenameData}{t}
\input{R/getCacheFilename}
\end{rlisting}

Before introduction of \mintinline{text}{DataLocation} objects, a fair amount of redundant code was necessary for simple tasks such as saving or retrieving cache files. Identity of datasets was mostly specified by passing plate barcodes and experiment names and from that information, paths were assembled. Cumbersome casting of letter case, splitting strings to separate pathogen from library and adding setup-specific strings (such as \mintinline{text}{_TEAM}, which added as suffix to an all caps pathogen name yields the openBIS project name) to generate the appropriate values determining local file paths, as well as performance issues due to constant lookups of the same information can altogether be avoided by using specialized objects containing all neccessary information. Furthermore, the S3 method dispatch system can be put to use for specifying different behavior dependent on the object that is used as function argument. For a small illustration of such as use case, see code listing \ref{lst:getCacheFilenameData}.

The two remaining auxiliary objects are both used for caching purposes. Due to the narrow purpose of \mintinline{text}{DataLocation} a lookup table containing all required information can be created, that remains small enough to be loaded quickly. This is not possible for creating metadata objects, as most aggregate file columns are required for this process. In order to prevent repeated loading of these large files (100--\SI{200}{\mega\byte}, plate-level excerpts are cached as \mintinline{text}{PlateAggregate} objects whenever first accessed. The resulting files are small (\tilde \SI{100}{\kilo\byte}) and can be attached quickly. The data structure is simple, containing of two slots \mintinline{text}{plate} and \mintinline{text}{data}, the former holding a \mintinline{text}{PlateLocation} object and the latter a \mintinline{text}{data.frame} storing the relevant 384 rows of the corresponding aggregate file.

Finally, \mintinline{text}{MatData} is a type of \mintinline{text}{Data} object, that can be though of as a precursor to a \mintinline{text}{PlateData} object. The reason for its existence lies in the dynamic nature of this project. Many parts of singleCellFeatures evolved considerably and constant change poses problems for cached data structures. Originally, \mintinline{text}{PlateData} objects themselves were saved to the local file system but whenever their implementation was modified, all instances had to be invalidated and rebuilt (which an the beginning took on the order of \SI{45}{\minute}). In order to improve the situation, not \mintinline{text}{PlateData} are written to disk, but a data structure that holds all MATLAB feature data in a large nested list, as it is imported into R. Two slots are available to a \mintinline{text}{MatData} object, one called \mintinline{text}{meta} and intended for holding a \mintinline{text}{PlateMetadata} object and the oder is named \mintinline{text}{data} and stores all single cell features.

This successfully addresses the outlined problem, since the raw data will not change frequently (it still can occur that for example new features are developed\footnote{The system is build with a fair amount of flexibility, as there are methods available for adding new features to existing \mintinline{text}{MatData} structures, including automatic invalidation of downstream well caches. Therefore, extraction of new features does not require the rebuild of whole \mintinline{text}{MatData} objects.}, or better segmentation is employed), but introduces a new issue: build up of \mintinline{text}{PlateData} objects from \mintinline{text}{MatData} has to be reasonably fast due to this being the first step in every interactive session. Some aspects of how this is achieved is discussed in section \ref{sec:data-import}.

None of these auxiliary data structures were implemented as S3 objects for simply defining a set of fields, but much rather for their capability of using generic functions that specify how a specific procedure is applied to the different object variants. While this by itself is not an indispensable feature, as one could simple choose different but related names for the set of procedures, it is greatly appreciated for helping in organizing code into functional units.

\section{Data Import}
\label{sec:data-import}


% include integrity check
\section{Metadata Management}
\label{sec:metadata-management}

\section{Data Manipulation}
% add, remove, melt
